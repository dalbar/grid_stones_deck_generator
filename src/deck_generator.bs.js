// Generated by BUCKLESCRIPT VERSION 4.0.17, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");

var DIM = Caml_exceptions.create("Deck_generator.DIM");

function generate_one_stone_permutations(row) {
  var fill_copy = function (idx) {
    var row$1 = row.slice(0);
    Belt_Array.setExn(row$1, idx, 1);
    return row$1;
  };
  var loop = function (perm, idx) {
    try {
      var cur_value = Belt_Array.getExn(row, idx);
      if (cur_value !== -1) {
        return loop(perm, idx + 1 | 0);
      } else {
        return loop(Belt_List.add(perm, fill_copy(idx)), idx + 1 | 0);
      }
    }
    catch (exn){
      return perm;
    }
  };
  return loop(Belt_List.make(0, row), 0);
}

function filter_dups_from_list(perm) {
  var no_dup = Belt_List.make(0, Belt_Array.make(0, 0));
  return Belt_List.reduce(perm, no_dup, (function (acc, row) {
                if (Belt_List.has(acc, row, (function (l1, l2) {
                          return Belt_Array.eq(l1, l2, Caml_obj.caml_equal);
                        }))) {
                  return acc;
                } else {
                  return Belt_List.add(acc, row);
                }
              }));
}

function generate_row_permutations(size, max_stones) {
  var empty_row = Belt_Array.make(size, -1);
  var res = Belt_List.make(1, empty_row);
  var loop = function (_cur_stones, _latest_rows, _res) {
    while(true) {
      var res = _res;
      var latest_rows = _latest_rows;
      var cur_stones = _cur_stones;
      if (cur_stones > max_stones) {
        return res;
      } else {
        var new_rows = Belt_List.flatten(Belt_List.map(latest_rows, generate_one_stone_permutations));
        _res = Belt_List.concat(res, latest_rows);
        _latest_rows = new_rows;
        _cur_stones = cur_stones + 1 | 0;
        continue ;
      }
    };
  };
  return filter_dups_from_list(loop(0, res, Belt_List.make(-1, empty_row)));
}

function append_matrix(matrix, rows) {
  var res = Belt_List.make(0, Belt_Array.make(0, 0));
  return Belt_List.reduce(rows, res, (function (acc, row) {
                return Belt_List.add(acc, Belt_Array.concat(matrix, row));
              }));
}

function shape_quad(m, array) {
  var len = array.length;
  if (Caml_int32.mod_(len, m) > 0) {
    throw [
          DIM,
          "Dimensions do not match!"
        ];
  } else {
    var res = Belt_Array.make(Caml_int32.div(len, m), Belt_Array.make(0, 0));
    var loop = function (_cur_idx) {
      while(true) {
        var cur_idx = _cur_idx;
        if (cur_idx > (len - m | 0)) {
          return /* () */0;
        } else {
          var new_row = Belt_Array.slice(array, cur_idx, m);
          Belt_Array.setExn(res, Caml_int32.div(cur_idx, m), new_row);
          _cur_idx = cur_idx + m | 0;
          continue ;
        }
      };
    };
    loop(0);
    return res;
  }
}

function has_at_least_n_stones(array, n) {
  return Belt_Array.reduce(array, 0, (function (acc, value) {
                if (value === 1) {
                  return acc + 1 | 0;
                } else {
                  return acc;
                }
              })) >= n;
}

function generate_pattern($staropt$star, size, max_stones) {
  var min_stones = $staropt$star !== undefined ? $staropt$star : 0;
  var rows = generate_row_permutations(size, max_stones);
  var loop = function (_cur_rows, _res) {
    while(true) {
      var res = _res;
      var cur_rows = _cur_rows;
      if (cur_rows > size) {
        return res;
      } else {
        var new_res = Belt_List.flatten(Belt_List.map(res, (function (matrix) {
                    return append_matrix(matrix, rows);
                  })));
        _res = new_res;
        _cur_rows = cur_rows + 1 | 0;
        continue ;
      }
    };
  };
  return Belt_List.map(Belt_List.keep(filter_dups_from_list(loop(0, rows)), (function (array) {
                    return has_at_least_n_stones(array, min_stones);
                  })), (function (matrix) {
                return shape_quad(size, matrix);
              }));
}

function write_deck(deck, dest) {
  Fs.writeFileSync(dest, deck, "ascii");
  return /* () */0;
}

function generate_size_3_stones_6(param) {
  var deck_string = $$String.concat(",\n", Belt_List.map(generate_pattern(5, 3, 6), (function (pattern) {
              return Belt_Option.getExn(Caml_option.undefined_to_opt(JSON.stringify(pattern)));
            })));
  return write_deck($$String.concat("\n", /* :: */[
                  "{ \"deck\": [",
                  /* :: */[
                    deck_string,
                    /* :: */[
                      "]}",
                      /* [] */0
                    ]
                  ]
                ]), "deck_3_6.json");
}

generate_size_3_stones_6(/* () */0);

exports.DIM = DIM;
exports.generate_one_stone_permutations = generate_one_stone_permutations;
exports.filter_dups_from_list = filter_dups_from_list;
exports.generate_row_permutations = generate_row_permutations;
exports.append_matrix = append_matrix;
exports.shape_quad = shape_quad;
exports.has_at_least_n_stones = has_at_least_n_stones;
exports.generate_pattern = generate_pattern;
exports.write_deck = write_deck;
exports.generate_size_3_stones_6 = generate_size_3_stones_6;
/*  Not a pure module */
